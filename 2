Filename: docs/proposals/03-intent-classifier-policy-engine.md
### Title
Intent Classifier + Policy Engine Router (IC+PE)

### Goals
- Separate intent detection from policy enforcement.
- Use a simple, auditable policy-as-code layer to compose rules.

### Assumptions
- Policies must be explainable and versioned.

### Architecture
- Stage 1: Intent Classifier (regex → ML optional)
- Stage 2: Entity Extractor (domain, lifecycle, risk level)
- Stage 3: Policy Engine (OPA-like) → capabilities → rules
- Stage 4: Overlays (security, governance)

### Sample Policy (YAML-like)
```yaml
policies:
  - name: always-apply-security
    when: true
    addCapabilities: [security.overlay]
  - name: risky-modifications
    when: intent.type == "modify" && entity.risk >= "medium"
    addCapabilities: [code.modify.safety, audit.run]
  - name: ui-accessibility
    when: entity.domain == "frontend"
    addCapabilities: [ui.interaction]
```

### Example Flow
- Msg: "Refactor login handler; add input validation"
  - intent: modify; entities: backend, risk=medium
  - policies → [security.overlay, code.modify.safety]
  - rules → [F8, 4-master-rule-code-modification-safety-protocol]

### Backward-Compat
- Old triggers populate initial intents; policies translate to capabilities.

### Trigger ↔ Rule(s) ↔ Files/Outputs
| Policy Outcome | Rule(s) | Outputs |
|---|---|---|
| add security.overlay | F8 | Threat model snippet |
| add audit.run | 8 | reports/audit-*.md |

### Alternatives
- Hard-coded mapping (faster, less flexible).
- Full ML router (opaque).

### Risks
- Policy sprawl; mitigate with linting and versioning.
- Misclassification; add human-in-the-loop on low confidence.

### Dependencies
- Policy store (git-managed).
- Lightweight classifier.

### Success Metrics
- Policy coverage of top 90% intents.
- Zero critical security regressions in routing.

### Next Steps
- Define policy DSL and validator.
- Seed baseline policies and tests.